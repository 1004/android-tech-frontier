服务测试
---

> * 原文链接 : [Service Testing](http://developer.android.com/tools/testing/service_testing.html)
* 原文作者 : [google develper](http://developer.android.com/)
* 译文出自 :  [开发技术前线 www.devtf.cn](http://www.devtf.cn)
* 译者 : [sjyin](https://github.com/yinshijian-kkb) 


Android provides a testing framework for Service objects that can run them in isolation and provides mock objects. The test case class for Service objects is ServiceTestCase. Since the Service class assumes that it is separate from its clients, you can test a Service object without using instrumentation.

Android为服务对象提供了一套测试框架，框架可以独立的运行，并且提供了模拟对象。这个测试用例类的名字叫做(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]。因为这个服务类是独立于客户端的，所以，你不用使用```instrumentation```就可以测试服务对象。

This document describes techniques for testing Service objects. If you aren't familiar with the Service class, please read the Services document. If you aren't familiar with Android testing, please read Testing Fundamentals, the introduction to the Android testing and instrumentation framework.

这篇文档描述了测试服务对象的技术。如果你对服务不熟悉，请阅读(服务)[http://developer.android.com/guide/components/services.html]文档。如果你不熟悉Android测试，请阅读介绍Android测试和instrumentation框架的(测试)[http://developer.android.com/tools/testing/testing_android.html]。

Service Design and Testing

***服务设计和测试***

When you design a Service, you should consider how your tests can examine the various states of the Service lifecycle. If the lifecycle methods that start up your Service, such as onCreate() or onStartCommand() do not normally set a global variable to indicate that they were successful, you may want to provide such a variable for testing purposes.

当你设计一个服务的时候，你应该考虑你的测试用例怎么样才能测试服务的整个生命周期。如果开启服务的方法，比如：```onCreate()```或者```onStartCommand()```并没有设置一个检测是否成功的全局变量，你可能想要提供一个以测试为目的的变量。

Most other testing is facilitated by the methods in the ServiceTestCase test case class. For example, the getService() method returns a handle to the Service under test, which you can test to confirm that the Service is running even at the end of your tests.

大多数其他的测试通过(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]的测试用例类来方便测试。例如，```getService()```方法在测试中返回一个处理服务的句柄，通过这个句柄你可以确定服务是否正在运行。

ServiceTestCase

***```ServiceTestCase```***

ServiceTestCase extends the JUnit TestCase class with with methods for testing application permissions and for controlling the application and Service under test. It also provides mock application and Context objects that isolate your test from the rest of the system.

(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]扩展了JUnit(测试用例)[http://developer.android.com/reference/junit/framework/TestCase.html]，添加测试应用权限、控制应用和服务的方法。它还提供了独立于系统的模拟的application和Context对象。

ServiceTestCase defers initialization of the test environment until you call ServiceTestCase.startService() or ServiceTestCase.bindService(). This allows you to set up your test environment, particularly your mock objects, before the Service is started.

(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]会在你的调用```ServiceTestCase.startService()```或```ServiceTestCase.bindService()```的时候初始化测试环境。这是为了允许你在启动服务之前初始化测试环境，尤其是你的模拟对象。

Notice that the parameters to ServiceTestCase.bindService()are different from those for Service.bindService(). For the ServiceTestCase version, you only provide an Intent. Instead of returning a boolean, ServiceTestCase.bindService() returns an object that subclasses IBinder.

注意：```Service.bindService()```的参数不同于```ServiceTestCase.bindService()```。因为```ServiceTestCase```的版本，你只能提供一个```Intent```。```ServiceTestCase.bindService()```会返回一个(IBinder)[http://developer.android.com/reference/android/os/IBinder.html]子对象，代替返回一个```boolean```值。

The setUp() method for ServiceTestCase is called before each test. It sets up the test fixture by making a copy of the current system Context before any test methods touch it. You can retrieve this Context by calling getSystemContext(). If you override this method, you must call super.setUp() as the first statement in the override.

(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]中的```setUp()```方法会在每次测试的时候调用。任何方法调用它，它都会创建一个当前系统上下文的拷贝。你可以通过调用```getSystemContext()```查看这个上下文对象。如果，你重写该方法，你必须在重写的方法中首先调用```super.setUp()```。

The methods setApplication() and setContext(Context) setContext()} allow you to set a mock Context or mock Application (or both) for the Service, before you start it. These mock objects are described in Mock object classes.

```setApplication()```和```setContext(Context) setContext()```允许你在开启服务之前为服务设置一个模拟的```Context```和```Application```（或者两者）。这些模拟的对象在(模拟对象集合)[http://developer.android.com/tools/testing/service_testing.html#MockObjects]中。

By default, ServiceTestCase runs the test method testAndroidTestCaseSetupProperly(), which asserts that the base test case class successfully set up a Context before running.

默认情况下，(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]运行```testAndroidTestCaseSetupProperly()```方法，去声明在测试启动之前已经成功的创建```Context```。

Mock object classes

***模拟对象集合***

ServiceTestCase assumes that you will use a mock Context or mock Application (or both) for the test environment. These objects isolate the test environment from the rest of the system. If you don't provide your own instances of these objects before you start the Service, then ServiceTestCase will create its own internal instances and inject them into the Service. You can override this behavior by creating and injecting your own instances before starting the Service

(ServiceTestCase)[http://developer.android.com/tools/testing/service_testing.html]假定你在测试环境中将会使用模拟的```Context```和```Application```（或者两者）。这些对象是跟系统分离的。如果你在启动服务之前不创建这些对象的实例，那么，(ServiceTestCase)[http://developer.android.com/reference/android/test/ServiceTestCase.html]
会创建它内部的实例并将它们注入到服务中。你可以在开启服务之前通过创建和注入你自己的实例对象来实现这一功能。

To inject a mock Application object into the Service under test, first create a subclass of MockApplication. MockApplication is a subclass of Application in which all the methods throw an Exception, so to use it effectively you subclass it and override the methods you need. You then inject it into the Service with the setApplication() method. This mock object allows you to control the application values that the Service sees, and isolates it from the real system. In addition, any hidden dependencies your Service has on its application reveal themselves as exceptions when you run the test.

在测试的时候，将一个模拟对象注入到服务中。
首先，创建一个(MockApplication)[http://developer.android.com/reference/android/test/mock/MockApplication.html]的子类。```MockApplication```是(Applicatoin)[http://developer.android.com/reference/android/app/Application.html]的子类。然后，使用```setApplication()```服务中。这个模拟对象允许你操作服务中的值，并且独立真实的系统。而且，当你运行测试的时候，你的服务中任何隐藏的应用依赖将会被当做异常处理。

You inject a mock Context into the Service under test with the setContext() method. The mock Context classes you can use are described in more detail in Testing Fundamentals.
服务中。在(基础测试)[http://developer.android.com/tools/testing/testing_android.html#MockObjectClasses]中，模拟的```Context```可以描述更多细节。

What to Test

***测试什么***

The topic What To Test lists general considerations for testing Android components. Here are some specific guidelines for testing a Service:

(测试什么)[http://developer.android.com/tools/testing/what_to_test.html]这一主题下列出了测试android组件一般考虑的问题。这些是测试服务的具体指导：

Ensure that the onCreate() is called in response to Context.startService() or Context.bindService(). Similarly, you should ensure that onDestroy() is called in response to Context.stopService(), Context.unbindService(), stopSelf(), or stopSelfResult().

确保调用```Context.startService()```或```Context.bindService()```时```onCreate()```做出了响应。同理，调用```Context.stopService()```,```Context.unbindService()```,```stopSelf()```, 或者```stopSelfResult()```时```onDestroy()```做出了响应。

Test that your Service correctly handles multiple calls from Context.startService(). Only the first call triggers Service.onCreate(), but all calls trigger a call to Service.onStartCommand().

多次调用```Context.startService()```只有第一次才会触发```Service.onCreate()```方法，但是所有的调用都会触发```Service.onStartCommand()```。

In addition, remember that startService() calls don't nest, so a single call to Context.stopService() or Service.stopSelf() (but not stopSelf(int)) will stop the Service. You should test that your Service stops at the correct point.
Test any business logic that your Service implements. Business logic includes checking for invalid values, financial and arithmetic calculations, and so forth.

另外，记着```startService()```不能够嵌套调用，所以，```Context.stopService()```或者```Service.stopSelf()```（不是```stopSelf(int)```）任意一个方法都可以停止服务。你应该测试你的服务是不是在正确的时间点关闭。
测试服务中的每个业务逻辑。业务逻辑包括无效值的检查，算法的计算等等。




开发第一个应用之前你需要知道的六件事
---
> * 原文链接 : [6 THINGS I WISH I KNEW BEFORE I WROTE MY FIRST ANDROID APP](http://www.philosophicalhacker.com/2015/07/09/6-things-i-wish-i-knew-before-i-wrote-my-first-android-app/)
* 原文作者 : [Philosophical Hacker](http://www.philosophicalhacker.com/)
* [译文出自 :  开发技术前线 www.devtf.cn](http://www.devtf.cn)
* 译者 : [dengshiwei](https://github.com/dengshiwei) 
* 校对者: [这里校对者的github用户名](github链接)  
* 状态 :  未完成 / 校对中 / 完成 

My first app was terrible. It was so terrible, in fact, that I removed it from the store and I don’t even bother listing it on my resume’ anymore. That app wouldn’t have been so terrible if I knew a few things about Android development before I wrote it.

我的第一个应用非常糟糕。事实上，它非常的糟糕以致于我从应用市场上删除它，同时我甚至不在我的简历上罗列出它。如果我在开发之前知道一些安卓开发的事情，它就不会那么糟糕。

Here’s a list of things to keep in mind as you’re writing your first Android apps. These lessons are derived from actual mistakes that I made in the source code of my first app, mistakes that I’ll be showing below. Keeping these things in mind will help you write an app that you can be a little prouder of.

这列罗列的事情在你开发第一个安卓应用的时候需要牢记在大脑中。这些我接下来将展示的实际错误来自于我的第一个应用程序代码中。把这些错误经验牢记心头能够帮助你开发一个你可以引以为豪的应用。

Of course, if you’re doing your job right as a student of Android development, you’ll probably hate your app later regardless. As @codestandards says,

 *If the code you wrote a year ago doesn’t seem bad to you, you’re probably not learning enough.*

*— Code Standards (@codestandards) May 21, 2015*

If you’re an experienced Java developer, items 1, 2, and 5 probably won’t be interesting to you. Items 3 and 4, on the other hand, might show you some cool stuff you can do with Android Studio that you might not have known about, even if you’ve never been guilty of making the mistakes I demo in those items.

当然，正如codestandards所说：“如果你所做的工作和你作为学生开发的安卓类似，你很有可能会讨厌你的应用”。

 *如果一年前你写的代码对于你来说感觉还不错，你很大程度上没有进行足够的学习。*

*-Code Standards  2015.5.21*

如果你是一位经验丰富的java开发者，第1、2、5条很有可能对你没有吸引力。另一方面，即使你从来没有犯过这些例子中的错误，第3、4条也可能向你展示一些很酷的事物，你可以利用一款也许你不知道的软件Android Studio去实现这些事物。

###1. Don’t have static references to Contexts

	public class MainActivity extends LocationManagingActivity implements ActionBar.OnNavigationListener,
        GooglePlayServicesClient.ConnectionCallbacks,
        GooglePlayServicesClient.OnConnectionFailedListener {
    	//...
    	private static MeTrackerStore mMeTrackerStore; 
  	  	//...
   	 	@Override
   		protected void onCreate(Bundle savedInstanceState) {
        	//...
       		mMeTrackerStore = new MeTrackerStore(this);
    	}
	}

This might seem like an impossible mistake for anyone to make. Its not. I made this mistake. I’ve seen others make this mistake, and I’ve interviewed people who weren’t very quick at figuring out why this is a mistake in the first place. Don’t do this. Its a n00b move.

If MeTrackerStore keeps a reference to the Activity passed into its constructor, the Activity will never be garbage collected. (Unless the static variable is reassigned to a different Activity.) This is because mMeTrackerStore is static, and the memory for static variables isn’t reclaimed until the process in which the application is running quits. If you find yourself tempted to do this, there’s probably something seriously wrong with your code. Find help. Maybe looking at Google’s Udacity course on “[Android Development for Beginners](https://www.udacity.com/course/android-development-for-beginners--ud837)” will help you out.

Note: Technically, you can hold a static reference to an application Context without causing a memory leak, but [I wouldn’t recommend that you do that either](http://www.philosophicalhacker.com/2015/07/14/why-static-references-to-application-contexts-are-probably-not-the-best-idea/). 

###1.不要在Context中持有静态引用

	public class MainActivity extends LocationManagingActivity implements ActionBar.OnNavigationListener,
        GooglePlayServicesClient.ConnectionCallbacks,
        GooglePlayServicesClient.OnConnectionFailedListener {
    	//...
    	private static MeTrackerStore mMeTrackerStore; 
  	  	//...
   	 	@Override
   		protected void onCreate(Bundle savedInstanceState) {
        	//...
       		mMeTrackerStore = new MeTrackerStore(this);
    	}
	}

这对于每个人来说看似是一个不可能犯的错误。它不是，我犯了这个错误。我也看到过别人犯这个错误，同时我也采访过那些不能很快指出为什么这是放在第一位的错误的人。不要这样做，它是会变的。

如果MeTrackerStore 通过它的构造函数保持一个指向Activity的引用，这个Activity将不会被垃圾回收(GC)。（除非静态变量被从新分配到不同的Activity）。这是因为mMeTrackerStore 是静态变量，而静态变量的内存是不会被回收，直到应用程序退出才回收。如果你正在试图做这样的事情，你的代码很有可能有严重的错误。寻找帮助吧，可能看看谷歌的Udacity 课程“[Android Development for Beginners](https://www.udacity.com/course/android-development-for-beginners--ud837)”能够帮助你。

注：从技术上说，你可以对一个应用程序上下文进行静态变量引用而不引起内存泄露，[但我不建议你这样做](http://www.philosophicalhacker.com/2015/07/14/why-static-references-to-application-contexts-are-probably-not-the-best-idea/)。

###2. Beware of “implicit references” to objects whose lifecycle you do not control

	public class DefineGeofenceFragment extends Fragment {
    	public class GetLatAndLongAndUpdateMapCameraAsyncTask extends 	AsyncTask<String, Void, LatLng> {

       	 	@Override
        	protected LatLng doInBackground(String... params) {
           		 //...
            	 try {
	                //Here we make the http request for the place search suggestions
	                httpResponse = httpClient.execute(httpPost);
	                HttpEntity entity = httpResponse.getEntity();
	                inputStream = entity.getContent();
	                //..
            	}
        	}
    	}
	}

There’s multiple problems with this code. I’m only going to focus on one of those problems. In Java, (non-static) inner classes have an implicit reference to the instances of the class that encloses them.

In this example, any GetLatAndLongAndUpdateMapCameraAsyncTask would have a reference to the DefineGeofenceFragment that contains it. The same thing is true for anonymous classes: they have an implicit reference to instances of the class that contains the anonymous class.

The GetLatAndLongAndUpdateMapCameraAsyncTask has an implicit reference to a Fragment, an object whose lifecycle we don’t control. The Android SDK is responsible for creating and destroying Fragments appropriately and if GetLatAndLongAndUpdateCameraAsyncTask can’t be garbage collected because its still executing, the DefineGeofenceFragment that it implicitly refers to will also be kept from being garbage collected.

There’s a great Google IO video [that explains why this sort of thing happens.](https://www.youtube.com/watch?v=_CruQY55HOk)

###2.注意无法控制生命周期对象的"隐式引用"

	public class DefineGeofenceFragment extends Fragment {
    	public class GetLatAndLongAndUpdateMapCameraAsyncTask extends 	AsyncTask<String, Void, LatLng> {

       	 	@Override
        	protected LatLng doInBackground(String... params) {
           		 //...
            	 try {
	                //Here we make the http request for the place search suggestions
	                httpResponse = httpClient.execute(httpPost);
	                HttpEntity entity = httpResponse.getEntity();
	                inputStream = entity.getContent();
	                //..
            	}
        	}
    	}
	}

这段代码有很多问题，我将只会把重点问题放在“隐式引用”那些问题上。在Java中，（非静态）内部类有个对外部类实例有个隐式引用。

在这个例子中，任何GetLatAndLongAndUpdateCameraAsyncTask都有一个外部类DefineGeofenceFragment的引用。对于匿名类是同样的，它们也有一个对包含它们的类的实例的一个隐式引用。

GetLatAndLongAndUpdateCameraAsyncTask对生命周期我们无法控制的Fragment对象有一个隐式引用。Android SDK负责创建和销毁Fragment，如果GetLatAndLongAndUpdateCameraAsyncTask 因为正在运行而不能被垃圾回收，那么DefineGeofenceFragment 也将因为具有隐式引用而保留不能被垃圾回收。

这里有一个很棒的谷歌视频，[解释它为什么会发生这种事情](https://www.youtube.com/watch?v=_CruQY55HOk)。

###3. Make Android Studio work for You

This snippet is what Android Studio generated when I used the “Generate Getter” code completion in Android Studio. The getter keeps the ‘m’ prefixed to the instance variable and uses it when generating a getter method name. This is not ideal.

(In case you’re wondering why ‘m’ is prefixed to the instance variable name in the first place: the ‘m’ is often prefixed to instance variables by convention. It stands for ‘member.’)

Regardless of whether you think prefixing ‘m’ to your instance variables is a good idea, there’s a lesson here: Android studio can help you code to whatever convention you adopt. For example, you can use the code style dialog in Android Studio to make Android Studio automatically prepend ‘m’ to your instance variable and automatically remove the ‘m’ when its generating getters, setters, and constructor params for the instance variables.

![AndroidStudio](http://i1.wp.com/www.philosophicalhacker.com/wp-content/uploads/2015/07/Screen-Shot-2015-07-09-at-4.16.13-PM.png)

Android Studio can do a lot more than that too. Learning shortcuts and learning about live templates are good places to start.

###3.使用Android Studio进行工作

这段代码是我使用“Generate Getter”在Android Studio中进行生成的。这些getter保持了'm'前缀的实例变量，同样通过它也能为一个方法产生相同的效果，这已经不是空想。

（如果你想知道为什么'm'是实例变量的名称的第一个字母,'m'往往是实例变量的公认约定。它代表了'member'(成员)的意思）。

不管你是否认为实例变量的前缀'm'是一个好注意，在这有一个知识，Android Studio能够帮助你编写任何你想要实现的公认约定。例如，在你为实例变量生成getters、setters和connstructor参数时，你可以使用Android Studio代码风格对话框的设置使Android Studio在你的实例变量前自动添加'm'和移除'm'。

![AndroidStudio](http://i1.wp.com/www.philosophicalhacker.com/wp-content/uploads/2015/07/Screen-Shot-2015-07-09-at-4.16.13-PM.png)

Android Studio能够做的远不止于此。学习Android Studio从学习快捷键和模版是不错的开始。

###4. Methods should do one thing

There’s a method in one of the classes that I wrote that’s over 100 lines long. Such methods are hard to read, modify, and reuse. Try to write methods that only do one thing. Typically, this means that you should be suspicious of methods that are over 20 lines long. Here you can recruit Android Studio to help you spot problematic methods:

![Method](http://i2.wp.com/www.philosophicalhacker.com/wp-content/uploads/2015/07/Screen-Shot-2015-07-09-at-4.25.00-PM.png)

###4.方法应该有用

在我写的众多类中的一个类存在一个方法我写了有100多行。这类的方法是非常难以读懂、修改和重用。努力让一个方法只做一件事情。显然，这意味着你应该对超过20行的方法持有怀疑态度。这里，你可以使用Android Studio来帮助你发现有问题的方法：

![Method](http://i2.wp.com/www.philosophicalhacker.com/wp-content/uploads/2015/07/Screen-Shot-2015-07-09-at-4.25.00-PM.png)

###5. Learn from other people who are smarter and more experienced than you.

This might sound trivial, but its a mistake that I made when I wrote my first app.

When you’re writing an app you’re going to make mistakes. Other people have already made those mistakes. Learn from those people. You’re wasting your time if you repeat the avoidable mistakes of others. I wasted a ton of time on my first app making mistakes that I could have avoided if I just spent a little more time learning from experienced software developers.

Read [Pragmatic Programmer](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X). Then read [Effective Java](http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683). These two books will help you avoid making common mistakes that we make as novice developers. After you done with those books, keep looking for smart people to learn from.

###5.向聪明和有经验的人看齐

这可能听起来微不足道，但是这是我开发我的第一个应用时候犯下的错误。

当你开发一个应用的时候，你会犯别人已经犯过的错误。向别人学习，你可以避免犯别人犯过的错误来节约你的时间。我在我的第一个应用中浪费了大量的时间犯错，这些错误如果我花点时间向有经验的软件开发工程师学习就可以避免。

阅读[Pragmatic Programmer](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X)，然后阅读[Effective Java](http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683)。这两本书会帮助你避免开发新手常犯的错误。在你学习了这两本书后，不停地寻找聪明的人并向他们学习。

###6. Use Libraries

When you’re writing an app, you’re probably going to encounter problems that smarter and more experienced people have already solved. Moreover, a lot of these solutions are available as open source libraries. Take advantage of them.

In my first app, I wrote code that provided functionality that’s already provided by libraries. Some of those libraries are standard java ones. Others are third-party libraries like Retrofit and Picasso. If you’re not sure what libraries you should be using you can do three things:

1. Listen to the [Google IO Fragmented podcast episode](http://fragmentedpodcast.com/episodes/9/). In this episode the ask developers what 3rd party libraries they see as essential for Android development. Spoiler: its mostly Dagger, Retrofit, Picasso, and Mockito.

2. Subscribe to [Android Weekly](http://androidweekly.net/). They’ve got a section that contains the latest libraries that are coming out. Keep an eye out for what seems useful to you.

3. Look for open source applications that solve problems similar to the ones that you are solving with your app. You might find one that uses a third-party library that you want to use or you might find that they’ve used a standard java library that you were unaware of.

###6.使用类库

当你开发应用的时候，你可能会遇到一些聪明人和有经验人已经解决过的问题。而且，许多这些问题的解决方案是可以作为开源库的，充分利用它们。

在我的第一个应用中，我写了一些类库已经提供的功能代码。其中一些是java标准库，还有一些是第三方类库，如Retrofit和Picasso。如果你不确定你使用什么样的类库，你可以做下面3件事情：

1. 听[Google IO Fragmented](http://fragmentedpodcast.com/episodes/9/)广播。在这期间，询问这些开发者什么第三方类库类库对Android很重要。

2. 订阅[Android周刊](http://androidweekly.net/)。这里包含了一部分最新的类库，时刻注意哪些对自己有用。

3. 寻找那些能够解决与你在开发应用中遇到问题类似的开源应用。你可能发现某个应用使用的第三方类库就是你想要的，或者你会发现一个你所不知道的java类库。

###Conclusion

Writing good Android apps can be very difficult. Don’t make it harder on yourself by repeating the mistakes I made. If you found a mistake in what I’ve written, please let me know in the comments. (Misleading comments are worse than no comments at all.) If you think this’ll be useful for a new developer, share it. Save them some headache.

###总结

开发优秀的Android应用是非常困难的。不要犯曾经犯下的错误来难为自己。如果你发现我写的代码中的错误请在评论中告诉我。（误导性评论比没有评论更糟糕）。如果你认为这篇文章对于新手开发者有用，请分享它。解决他们的一些令人头疼的难题。

